<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transwonderland-Lost Friend</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
        }
        #gameCanvas {
            border: 2px solid #e94560;
            background: #16213e;
            display: block;
            margin: 0 auto;
        }
        #message {
            margin-top: 20px;
            padding: 15px;
            background: #0f3460;
            color: white;
            border: 2px solid #e94560;
            border-radius: 4px;
            max-width: 600px;
            min-height: 60px;
            text-align: center;
            font-size: 1.1rem;
        }
        #status {
            margin-top: 10px;
            padding: 10px;
            background: #0f3460;
            color: white;
            border: 2px solid #e94560;
            border-radius: 4px;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
        }
        #riddle-box {
            margin-top: 10px;
            padding: 15px;
            background: #2a2a4a;
            color: white;
            border: 2px solid #e94560;
            border-radius: 4px;
            max-width: 600px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .riddle-btn {
            background: #0f3460;
            color: white;
            border: 2px solid #e94560;
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }
        .riddle-btn:hover {
            background: #e94560;
        }
        #loading {
            color: #fff;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div id="message">Welcome to Lagos... Find your friend.</div>
        <div id="status">
            <span>Health: ❤️ <span id="health">5</span></span>
            <span>Has Map: <span id="hasMap">No</span></span>
        </div>
        <div id="riddle-box"></div>
        <div id="loading">Loading images...</div>
    </div>

    <script>
        // ------------------------------------------------------------
        // CANVAS & SETUP
        // ------------------------------------------------------------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('message');
        const healthSpan = document.getElementById('health');
        const hasMapSpan = document.getElementById('hasMap');
        const riddleBox = document.getElementById('riddle-box');
        const loadingDiv = document.getElementById('loading');

        const TILE_SIZE = 40;
        const MAP_WIDTH = 15;
        const MAP_HEIGHT = 10;

        // ------------------------------------------------------------
        // GAME STATE
        // ------------------------------------------------------------
        const state = {
            health: 5,
            hasMap: false,
            friendFound: false,
            currentScene: 'lagos',     // 'lagos' or 'wasteland'
            inCombat: false,
            combatEnemy: null,
            riddleActive: false,
            riddleCallback: null,
        };

        // ------------------------------------------------------------
        // SCENES (maps, NPCs, enemies)
        // ------------------------------------------------------------
        const scenes = {
            lagos: {
                name: 'Lagos',
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,2,0,0,0,0,0,1], // 2 = transition to wasteland
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,3,0,0,0,0,0,0,0,0,0,1], // 3 = NPC (market woman)
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                npcs: [
                    { x: 4, y: 4, name: 'Market Woman', 
                      dialogue: 'Ah, you look for your friend? She went toward the old island. But beware, the place is cursed.', 
                      riddle: null },
                ],
                enemies: [
                    // no enemies in Lagos
                ],
                transitionTiles: [
                    { tile: 2, scene: 'wasteland', x: 5, y: 5 } // when step on tile 2, go to wasteland at player coords (5,5)
                ]
            },
            wasteland: {
                name: 'Dystopian Wasteland',
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,1,1,0,0,0,0,0,0,1,1,1,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,4,0,0,0,0,0,0,1], // 4 = creepy creature (enemy)
                    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ],
                npcs: [
                    { x: 10, y: 3, name: 'Mystic', 
                      dialogue: 'To find your friend, answer me this: Your friend saw Ads covering the undersides of these. What are they?',
                      riddle: {
                          question: 'I speak without a mouth and hear without ears. I have no body, but I come alive with wind. What am I?',
                          options: ['Unpainted walls', 'Brazilian Baroque tiles', 'Danfoes', 'Pedestrian bridges'],
                          correct: 3, // index of correct answer
                          successMessage: 'Correct! Take this map – it shows where your friend is.',
                          item: 'hasMap'
                      }
                    },
                ],
                enemies: [
                    { x: 7, y: 7, name: 'Creepy Creature', health: 3, attack: 1 },
                ],
                transitionTiles: [
                    // none back to Lagos (maybe later)
                ]
            }
        };

        // ------------------------------------------------------------
        // PLAYER
        // ------------------------------------------------------------
        const player = {
            x: 7,
            y: 7
        };

        // ------------------------------------------------------------
        // IMAGES
        // ------------------------------------------------------------
        const playerImg = new Image();
        playerImg.src = 'images/hero1.png';
        const enemyImg = new Image();
        enemyImg.src = 'images/enemy2.png';   // used for enemies and NPCs (you can add more images later)

        let imagesLoaded = 0;
        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === 2) {
                loadingDiv.textContent = 'Ready!';
            } else {
                loadingDiv.textContent = `Loading images... (${imagesLoaded}/2)`;
            }
        }
        playerImg.onload = imageLoaded;
        playerImg.onerror = () => { loadingDiv.textContent = 'Error loading player.png'; };
        enemyImg.onload = imageLoaded;
        enemyImg.onerror = () => { loadingDiv.textContent = 'Error loading enemy.png'; };

        // ------------------------------------------------------------
        // HELPER FUNCTIONS
        // ------------------------------------------------------------
        function getCurrentScene() {
            return scenes[state.currentScene];
        }

        function getMap() {
            return getCurrentScene().map;
        }

        function isWalkable(tx, ty) {
            const map = getMap();
            if (ty < 0 || ty >= MAP_HEIGHT || tx < 0 || tx >= MAP_WIDTH) return false;
            return map[ty][tx] === 0 || map[ty][tx] >= 2; // allow special tiles (NPCs, transitions)
        }

        // Check for special tile actions
        function checkSpecialTile(tx, ty) {
            const tile = getMap()[ty][tx];
            const scene = getCurrentScene();

            // Transition tiles
            if (scene.transitionTiles) {
                for (let t of scene.transitionTiles) {
                    if (t.tile === tile) {
                        // Switch scene
                        state.currentScene = t.scene;
                        player.x = t.x;
                        player.y = t.y;
                        messageBox.textContent = `You enter the ${scenes[t.scene].name}.`;
                        return;
                    }
                }
            }

            // NPCs
            for (let npc of scene.npcs) {
                if (npc.x === tx && npc.y === ty) {
                    talkToNPC(npc);
                    return;
                }
            }

            // Enemies (only if not already in combat)
            for (let i = 0; i < scene.enemies.length; i++) {
                let enemy = scene.enemies[i];
                if (enemy.x === tx && enemy.y === ty) {
                    startCombat(enemy, i);
                    return;
                }
            }
        }

        // ------------------------------------------------------------
        // NPC & RIDDLE SYSTEM
        // ------------------------------------------------------------
        function talkToNPC(npc) {
            if (npc.riddle) {
                // Show riddle box
                messageBox.textContent = npc.dialogue;
                showRiddle(npc.riddle);
            } else {
                messageBox.textContent = npc.dialogue;
            }
        }

        function showRiddle(riddle) {
            state.riddleActive = true;
            riddleBox.style.display = 'flex';
            riddleBox.innerHTML = `<p>${riddle.question}</p>`;
            riddle.options.forEach((opt, index) => {
                const btn = document.createElement('button');
                btn.className = 'riddle-btn';
                btn.textContent = opt;
                btn.onclick = () => {
                    if (index === riddle.correct) {
                        // Correct answer
                        messageBox.textContent = riddle.successMessage;
                        if (riddle.item) {
                            state[riddle.item] = true;
                            updateStatus();
                        }
                        // Possibly give item or progress
                    } else {
                        messageBox.textContent = 'Wrong answer. Try again?';
                        // They can try again; we don't close the box.
                        return;
                    }
                    // Close riddle box
                    riddleBox.style.display = 'none';
                    state.riddleActive = false;
                };
                riddleBox.appendChild(btn);
            });
            // Add a cancel button
            const cancel = document.createElement('button');
            cancel.className = 'riddle-btn';
            cancel.textContent = 'Leave';
            cancel.onclick = () => {
                riddleBox.style.display = 'none';
                state.riddleActive = false;
            };
            riddleBox.appendChild(cancel);
        }

        // ------------------------------------------------------------
        // COMBAT SYSTEM (simple)
        // ------------------------------------------------------------
        function startCombat(enemy, index) {
            if (state.inCombat) return;
            state.inCombat = true;
            state.combatEnemy = { ...enemy, index }; // copy
            messageBox.textContent = `You encounter a ${enemy.name}! It attacks!`;
            // In a real game you'd have combat options. Here we just auto-attack each turn.
            // For simplicity, we'll let the player "fight" by moving away? Better: give a button.
            // We'll create a simple combat prompt inside message box.
            showCombatOptions();
        }

        function showCombatOptions() {
            const enemy = state.combatEnemy;
            // Create temporary buttons
            const combatDiv = document.createElement('div');
            combatDiv.id = 'combat-options';
            combatDiv.style.marginTop = '10px';
            combatDiv.innerHTML = `
                <button class="riddle-btn" id="attack-btn">Attack</button>
                <button class="riddle-btn" id="flee-btn">Flee</button>
            `;
            messageBox.innerHTML = `Fighting ${enemy.name}. Enemy health: ${enemy.health}<br>`;
            messageBox.appendChild(combatDiv);

            document.getElementById('attack-btn').onclick = () => {
                // Player attacks
                enemy.health -= 1;
                if (enemy.health <= 0) {
                    messageBox.innerHTML = `You defeated the ${enemy.name}!`;
                    removeEnemy(enemy.index);
                    endCombat();
                } else {
                    // Enemy counterattacks
                    state.health -= enemy.attack;
                    updateStatus();
                    if (state.health <= 0) {
                        messageBox.innerHTML = 'You have been defeated... Game Over. Reload to try again.';
                        // Disable movement etc.
                        state.inCombat = false; // but game over
                        return;
                    }
                    // Update message
                    messageBox.innerHTML = `You attack! Enemy health: ${enemy.health}. It hits you back! Your health: ${state.health}<br>`;
                    messageBox.appendChild(combatDiv); // re-add buttons
                }
            };

            document.getElementById('flee-btn').onclick = () => {
                // 50% chance to flee
                if (Math.random() < 0.5) {
                    messageBox.innerHTML = 'You fled successfully!';
                    endCombat();
                } else {
                    messageBox.innerHTML = 'Failed to flee! Enemy attacks.';
                    state.health -= enemy.attack;
                    updateStatus();
                    if (state.health <= 0) {
                        messageBox.innerHTML = 'Game Over.';
                        return;
                    }
                    messageBox.innerHTML += ` Your health: ${state.health}`;
                    messageBox.appendChild(combatDiv);
                }
            };
        }

        function removeEnemy(index) {
            const scene = getCurrentScene();
            scene.enemies.splice(index, 1);
        }

        function endCombat() {
            state.inCombat = false;
            state.combatEnemy = null;
            // Remove combat buttons
            const oldCombat = document.getElementById('combat-options');
            if (oldCombat) oldCombat.remove();
            // Optionally, give a reward
            if (!state.hasMap) {
                // maybe drop a clue
            }
        }

        // ------------------------------------------------------------
        // MOVEMENT
        // ------------------------------------------------------------
        function movePlayer(dx, dy) {
            if (state.inCombat || state.riddleActive) {
                messageBox.textContent = 'You are busy!';
                return;
            }
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (isWalkable(newX, newY)) {
                player.x = newX;
                player.y = newY;
                checkSpecialTile(newX, newY);
            }
        }

        // ------------------------------------------------------------
        // UPDATE UI
        // ------------------------------------------------------------
        function updateStatus() {
            healthSpan.textContent = state.health;
            hasMapSpan.textContent = state.hasMap ? 'Yes' : 'No';
        }

        // ------------------------------------------------------------
        // DRAWING
        // ------------------------------------------------------------
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const map = getMap();
            const scene = getCurrentScene();

            // Draw tiles
            for (let row = 0; row < MAP_HEIGHT; row++) {
                for (let col = 0; col < MAP_WIDTH; col++) {
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;
                    const tile = map[row][col];
                    if (tile === 1) {
                        ctx.fillStyle = '#555'; // wall
                        ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                    } else {
                        ctx.fillStyle = '#2a2a4a'; // floor
                        ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                        ctx.strokeStyle = '#333';
                        ctx.strokeRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                        // Special tile colors (for debugging, can be replaced with images)
                        if (tile === 2) {
                            ctx.fillStyle = '#ffaa00'; // transition (orange)
                            ctx.globalAlpha = 0.5;
                            ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                            ctx.globalAlpha = 1;
                        } else if (tile === 3) {
                            ctx.fillStyle = '#00ffaa'; // NPC (greenish)
                            ctx.globalAlpha = 0.5;
                            ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                            ctx.globalAlpha = 1;
                        } else if (tile === 4) {
                            ctx.fillStyle = '#ff0000'; // enemy (red)
                            ctx.globalAlpha = 0.5;
                            ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                            ctx.globalAlpha = 1;
                        }
                    }
                }
            }

            // Draw NPCs (using enemyImg as placeholder)
            for (let npc of scene.npcs) {
                if (enemyImg.complete && enemyImg.naturalHeight) {
                    ctx.drawImage(enemyImg, npc.x * TILE_SIZE, npc.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#00ffaa';
                    ctx.fillRect(npc.x * TILE_SIZE, npc.y * TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
                }
            }

            // Draw enemies
            for (let enemy of scene.enemies) {
                if (enemyImg.complete && enemyImg.naturalHeight) {
                    ctx.drawImage(enemyImg, enemy.x * TILE_SIZE, enemy.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x * TILE_SIZE, enemy.y * TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
                }
            }

            // Draw player
            if (playerImg.complete && playerImg.naturalHeight) {
                ctx.drawImage(playerImg, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else {
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
            }
        }

        // ------------------------------------------------------------
        // GAME LOOP
        // ------------------------------------------------------------
        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ------------------------------------------------------------
        // KEYBOARD
        // ------------------------------------------------------------
        window.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow')) e.preventDefault();
            if (state.inCombat || state.riddleActive) return;
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });

        // Start
        gameLoop();
        updateStatus();
    </script>
</body>
</html>
